import React, { useState, useRef } from "react";
import { Button, Stack } from "@mui/material";
import { createClient } from '@supabase/supabase-js';
import MicIcon from "@mui/icons-material/Mic";
import SendIcon from "@mui/icons-material/Send";

function Record() {
  // supabase stuff
  const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
  const supabaseKey = import.meta.env.VITE_SUPABASE_ANON_KEY;
  const supabase = createClient(supabaseUrl, supabaseKey);

  // audio stuff
  const [isRecording, setIsRecording] = useState(false);
  const [audioBlob, setAudioBlob] = useState(null);
  const [sendDisabled, setSendDisabled] = useState(true);
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);

  // encryption stuff
  // const [passphrase, setPassphrase] = useState();

  const generateRandId = () => {
    // Generated by copilot
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 16; i++) {
      const randomIndex = Math.floor(Math.random() * characters.length);
      result += characters[randomIndex];
    }
    return result;
  }

  async function deriveKey(passphrase, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(passphrase),
      { name: "PBKDF2" },
      false,
      ["deriveKey"]
    )

    return crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 100000,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256},
      false,
      ["encrypt", "decrypt"]
    )
  }

  async function encryptMessage(passphrase, audio) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(passphrase, salt);

    const arrayBuffer = await audio.arrayBuffer();

    const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      arrayBuffer
    )

    return {
      ciphertext: new Uint8Array(encrypted),
      salt: btoa(String.fromCharCode(...salt)),
      iv: btoa(String.fromCharCode(...iv))
    }
  }

  const startRecording = async () => {
    try {
      // Request access to the user's microphone
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // Initialize MediaRecorder
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;

      // Clear previous audio chunks
      audioChunksRef.current = [];

      // Collect audio data as it becomes available
      mediaRecorder.ondataavailable = (event) => {
        audioChunksRef.current.push(event.data);
      };

      // Handle recording stop
      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: "audio/webm" });
        setAudioBlob(audioBlob);
        setSendDisabled(false); // Enable the send button
        console.log("Recording complete:", audioBlob);
      };

      // Start recording
      mediaRecorder.start();
      setIsRecording(true);
      setSendDisabled(true); // Disable the send button while recording
    } catch (error) {
      console.error("Error accessing microphone:", error);
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop(); // Stop the recording
      setIsRecording(false);
    }
  };
  
  async function uploadAudio(audioBlob, passphrase) {
    const id = generateRandId();
    const fileName = `${id}`;
    const {ciphertext, salt, iv} = await encryptMessage(passphrase, audioBlob);

    const file = new Blob([ciphertext], { type: "application/octet-stream" })

    const { data, error } = await supabase.storage
    .from('encrypted-audio-messages')
    .upload(fileName, file, {
      metadata: {
        salt: btoa(String.fromCharCode(...salt)), // Store salt as Base64
        iv: btoa(String.fromCharCode(...iv)),     // Store iv as Base64
      },
    }); 
    
    if (error) {
        console.error("Error uploading audio:", error);
    } else {
        console.log("Audio uploaded successfully");
        alert(`Audio uploaded successfully, access it here:\nhttps://transmission.com?voiceId=${id}`)
    }

    const { data: metadata, error: metadataError } = await supabase.from('message_metadata').insert([{filename: fileName, salt: salt, iv: iv }])

    if (metadataError) {
      console.log(`Error uploading metadata`)
    } else {
      console.log(`Metadata uploaded successfully`)
    }
  }

  const sendAudio = () => {
    if (audioBlob) {
        const newPass = window.prompt("Enter a passphrase to secure your message:")
        if (newPass) {
          uploadAudio(audioBlob, newPass);
        }
    }
    // Reset the state after sending
    setAudioBlob(null);
    setSendDisabled(true);
  };

  return (
    <>
      <Stack direction="column" spacing={2} justifyContent="center" sx={{ mb: 2 }}>
        <Button
          variant="outlined"
          startIcon={<MicIcon />}
          onClick={isRecording ? stopRecording : startRecording}
        >
          {isRecording ? "Stop Recording" : "Record a Voice Message"}
        </Button>
        <Button
          fullWidth
          variant="outlined"
          endIcon={<SendIcon />}
          color="secondary"
          disabled={sendDisabled} // Disable until recording is complete
          onClick={sendAudio}
        >
          Send Voice Message
        </Button>
        {/* display audio player if an audioBlob exists */}
        {audioBlob && (
          <audio
            controls
            src={URL.createObjectURL(audioBlob)} // Preview the recorded audio
          />
        )}
      </Stack>
    </>
  );
}

export default Record;