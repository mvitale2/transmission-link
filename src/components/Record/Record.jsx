import React, { useState, useRef } from "react";
import { Button, IconButton, Stack, Typography, TextField } from "@mui/material";
import { supabase } from "../../SupabaseClient";
import MicIcon from "@mui/icons-material/Mic";
import SendIcon from "@mui/icons-material/Send";
import CopyIcon from '@mui/icons-material/ContentCopy';
import Visibility from '@mui/icons-material/Visibility'
import VisibilityOffIcon from '@mui/icons-material/VisibilityOff';
import InputAdornment from "@mui/material/InputAdornment";

function ShareLink({ id }) {
  const currentUrl = window.location.href;
  const baseUrl = currentUrl.replace(/\?.*/, '') //Remove any previous voiceids
  const shareLink = `${baseUrl}?voiceId=${id}`

  const handleCopy = async () => {
    try {
      navigator.clipboard.writeText(shareLink)
    } catch (error) {
      console.log(`Error copying: ${error}`)
    }
  }
  
  return (
    <Stack direction="row" spacing={2} justifyContent='center'>
      <Typography>
        {shareLink}
      </Typography>
      <Button startIcon={<CopyIcon/>} onClick={handleCopy}/>
    </Stack>
  )
}

// This component only appears once there is audio data to send
function PasswordField({ onPasswordChange, visible }) {
  const [showPassword, setShowPassword] = useState(false);
  
  const handleClick = () => {
    setShowPassword(!showPassword);
  };

    const handleChange = (e) => {
    const newPassword = e.target.value;
    onPasswordChange(newPassword); // Notify parent component of the password change
  };
 
  return (
    <div style={{ display: visible ? 'block' : 'none' }}> {/* Control visibility */}
      <Typography>
        Enter a password to send your message:
      </Typography>
      <TextField
        type={showPassword ? "text" : "password"}
        label="Password"
        onChange={handleChange} // Update local state and notify parent
        fullWidth
        InputProps={{
          endAdornment: (
            <InputAdornment position="end">
              <IconButton onClick={handleClick} edge="end">
                {showPassword ? <VisibilityOffIcon /> : <Visibility />}
              </IconButton>
            </InputAdornment>
          ),
        }}
      />
    </div>
  );
}

function Record() {
  const [isRecording, setIsRecording] = useState(false);
  const [audioBlob, setAudioBlob] = useState(null);
  const [sendDisabled, setSendDisabled] = useState(true);
  const [linkVisible, setLinkVisible] = useState(false)
  const [linkId, setLinkId] = useState('')
  const [password, setPassword] = useState('')
  const [showPasswordField, setShowPasswordField] = useState(false)
  const mediaRecorderRef = useRef(null);
  const audioChunksRef = useRef([]);

  // Notify Record component of the password
  const handlePasswordChange = (newPassword) => {
    setPassword(newPassword);
    setSendDisabled(newPassword === '');
  };

  // encryption stuff
  const generateRandId = () => {
    // Generated by copilot
    const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let result = '';
    for (let i = 0; i < 16; i++) {
      const randomIndex = Math.floor(Math.random() * characters.length);
      result += characters[randomIndex];
    }
    return result;
  }

  async function deriveKey(passphrase, salt) {
    const encoder = new TextEncoder();
    const keyMaterial = await crypto.subtle.importKey(
      "raw",
      encoder.encode(passphrase),
      { name: "PBKDF2" },
      false,
      ["deriveKey"]
    )

    return crypto.subtle.deriveKey(
      {
        name: "PBKDF2",
        salt,
        iterations: 100000,
        hash: "SHA-256"
      },
      keyMaterial,
      { name: "AES-GCM", length: 256},
      false,
      ["encrypt", "decrypt"]
    )
  }

  async function encryptMessage(passphrase, audio) {
    const salt = crypto.getRandomValues(new Uint8Array(16));
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const key = await deriveKey(passphrase, salt);

    const arrayBuffer = await audio.arrayBuffer();

    const encrypted = await crypto.subtle.encrypt(
      { name: "AES-GCM", iv },
      key,
      arrayBuffer
    )

    return {
      ciphertext: new Uint8Array(encrypted),
      salt: btoa(String.fromCharCode(...salt)),
      iv: btoa(String.fromCharCode(...iv))
    }
  }

  // audio stuff
  const startRecording = async () => {
    try {
      // Request access to the user's microphone
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

      // Initialize MediaRecorder
      const mediaRecorder = new MediaRecorder(stream);
      mediaRecorderRef.current = mediaRecorder;

      // Clear previous audio chunks
      audioChunksRef.current = [];

      // Collect audio data as it becomes available
      mediaRecorder.ondataavailable = (event) => {
        audioChunksRef.current.push(event.data);
      };

      // Handle recording stop
      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(audioChunksRef.current, { type: "audio/webm" });
        setAudioBlob(audioBlob);
        // setSendDisabled(false); // Enable the send button
        console.log("Recording complete:", audioBlob);
      };

      // Start recording
      mediaRecorder.start();
      setIsRecording(true);
      setSendDisabled(true); // Disable the send button while recording
    } catch (error) {
      console.error("Error accessing microphone:", error);
    }
  };

  const stopRecording = () => {
    if (mediaRecorderRef.current) {
      mediaRecorderRef.current.stop(); // Stop the recording
      setIsRecording(false);
      setShowPasswordField(['', true])
    }
  };
  
  async function uploadAudio(audioBlob, passphrase) {
    const id = generateRandId();
    const fileName = `${id}`;
    const {ciphertext, salt, iv} = await encryptMessage(passphrase, audioBlob);

    const file = new Blob([ciphertext], { type: "application/octet-stream" })

    const { data, error } = await supabase.storage
    .from('encrypted-audio-messages')
    .upload(fileName, file, {
      metadata: {
        salt: btoa(String.fromCharCode(...salt)), // Store salt as Base64
        iv: btoa(String.fromCharCode(...iv)),     // Store iv as Base64
      },
    }); 
    
    if (error) {
        console.error("Error uploading audio:", error);
    } else {
        console.log("Audio uploaded successfully");
        setLinkVisible(true)
        setLinkId(fileName)
    }

    const { data: metadata, error: metadataError } = await supabase.from('message_metadata').insert([{filename: fileName, salt: salt, iv: iv }])

    if (metadataError) {
      console.log(`Error uploading metadata`)
    } else {
      console.log(`Metadata uploaded successfully`)
    }
  }

  const sendAudio = () => {
    if (audioBlob && password) {
      uploadAudio(audioBlob, password);
      // Reset state
      setAudioBlob(null);
      setSendDisabled(true);
      setPassword('');
      setShowPasswordField(false);
    }
  };

  return (
    <>
      <Stack direction="column" spacing={2} justifyContent="center" sx={{ mb: 2 }}>
        <Button
          variant="outlined"
          startIcon={<MicIcon />}
          onClick={isRecording ? stopRecording : startRecording}
        >
          {isRecording ? "Stop Recording" : "Record a Voice Message"}
        </Button>
        <Button
          fullWidth
          variant="outlined"
          endIcon={<SendIcon />}
          color="secondary"
          disabled={sendDisabled} // Disable until recording is complete
          onClick={() => sendAudio(showPasswordField)}
        >
          Send Voice Message
        </Button>
        <PasswordField onPasswordChange={handlePasswordChange} visible={showPasswordField}/>
        {/* display audio player if an audioBlob exists */}
        {audioBlob && (
          <audio
            controls
            src={URL.createObjectURL(audioBlob)} // Preview the recorded audio
          />
        )}
      </Stack>
      {linkVisible ? (
        <ShareLink id={linkId} />
      ) : null}
    </>
  );
}

export default Record;